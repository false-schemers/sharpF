/* stak.sf */
/* Generated by #F $Id$ */
#ifdef PROFILE
#define host host_module_stak
#endif
#define MODULE module_stak
#define LOAD() 

/* standard includes */
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <assert.h>
/* extra includes */
#include <ctype.h>
#include <string.h>

/* standard definitions */

typedef ptrdiff_t obj;        /* pointers are this size, lower bit zero */
typedef ptrdiff_t cxoint_t;   /* same thing, used as integer */
typedef struct {              /* type descriptor */
  const char *tname;          /* name (debug) */
  void (*free)(void*);        /* deallocator */
} cxtype_t;

#define notobjptr(o)          (((char*)(o) - (char*)cxg_heap) & cxg_hmask)
#define isobjptr(o)           (!notobjptr(o))
#define notaptr(o)            ((o) & 1)
#define isaptr(o)             (!notaptr(o))

#define obj_from_obj(o)       (o)
#define obj_from_objptr(p)    ((obj)(p))
#define obj_from_size(n)      (((cxoint_t)(n) << 1) | 1)

#define objptr_from_objptr(p) (p)
#define objptr_from_obj(o)    ((obj*)(o))

#define size_from_obj(o)      ((int)((o) >> 1))

#define obj_from_case(n)      obj_from_objptr(cases+(n))
#define case_from_obj(o)      (objptr_from_obj(o)-cases)
#define obj_from_ktrap()      obj_from_size(0x5D56F806)
#define obj_from_void(v)      ((void)(v), obj_from_size(0x6F56DF77))

#define bool_from_obj(o)      (o)
#define bool_from_bool(b)     (b)
#define bool_from_size(s)     (s)

#define void_from_void(v)     (void)(v)
#define void_from_obj(o)      (void)(o)

#define rreserve(m)           if (r + (m) >= cxg_rend) r = cxm_rgc(r, m)
#define hpushptr(p, pt, l)    (hreserve(2, l), *--hp = (obj)(p), *--hp = (obj)(pt), (obj)(hp+1))   
#define hbsz(s)               ((s) + 1) /* 1 extra word to store block size */
#define hreserve(n, l)        ((hp < cxg_heap + (n)) ? hp = cxm_hgc(r, r+(l), hp, n) : hp)
#define hendblk(n)            (*--hp = obj_from_size(n), (obj)(hp+1))
#define hblklen(p)            size_from_obj(((obj*)(p))[-1])
#define hblkref(p, i)         (((obj*)(p))[i])

typedef obj (*cxhost_t)(obj);
typedef struct cxroot_tag {
  int globc; obj **globv;
  struct cxroot_tag *next;
} cxroot_t;

extern obj *cxg_heap;
extern obj *cxg_hp;
extern cxoint_t cxg_hmask;
extern cxroot_t *cxg_rootp;
extern obj *cxm_rgc(obj *regs, size_t needs);
extern obj *cxm_hgc(obj *regs, obj *regp, obj *hp, size_t needs);
extern obj *cxg_regs, *cxg_rend;
extern void cxm_check(int x, char *msg);
extern void *cxm_cknull(void *p, char *msg);
extern int cxg_rc;
extern char **cxg_argv;

/* extra definitions */
/* immediate object representation */
#define isimm(o, t) (((o) & 0xff) == (((t) << 1) | 1))
#define getimmu(o, t) (int)(((o) >> 8) & 0xffffff)
#define getimms(o, t) (int)(((((o) >> 8) & 0xffffff) ^ 0x800000) - 0x800000)
#define mkimm(o, t) ((((o) & 0xffffff) << 8) | ((t) << 1) | 1)
#ifndef NDEBUG
int isnative(obj o, cxtype_t *tp) {
  return isobjptr(o) && objptr_from_obj(o)[-1] == (obj)tp; 
}
void *getnative(obj o, cxtype_t *tp) {
  assert(isnative(o, tp));
  return (void*)(*objptr_from_obj(o));
}
#endif
#ifdef NDEBUG
   static int isnative(obj o, cxtype_t *tp) 
     { return isobjptr(o) && objptr_from_obj(o)[-1] == (obj)tp;  }
   #define getnative(o, t) ((void*)(*objptr_from_obj(o)))
#else
  extern int isnative(obj o, cxtype_t *tp);
  extern void *getnative(obj o, cxtype_t *tp);
#endif
/* booleans */
#define TRUE_ITAG 0
typedef int bool_t;
#define is_bool_obj(o) (!((o) & ~(obj)1))
#define is_bool_bool(b) ((b), 1)
#define void_from_bool(b) (void)(b)
#define obj_from_bool(b) ((b) ? mkimm(0, TRUE_ITAG) : 0)
/* fixnums */
#define FIXNUM_ITAG 1
typedef int fixnum_t;
#define is_fixnum_obj(o) (isimm(o, FIXNUM_ITAG))
#define is_fixnum_fixnum(i) ((i), 1)
#define fixnum_from_obj(o) (getimms(o, FIXNUM_ITAG))
#define fixnum_from_fixnum(i) (i)
#define void_from_fixnum(i) (void)(i)
#define obj_from_fixnum(i) mkimm(i, FIXNUM_ITAG)
#define FIXNUM_MIN -8388608
#define FIXNUM_MAX 8388607
/* characters */
#define CHAR_ITAG 2
typedef int char_t;
#define is_char_obj(o) (isimm(o, CHAR_ITAG))
#define is_char_char(i) ((i), 1)
#define char_from_obj(o) (getimms(o, CHAR_ITAG))
#define char_from_char(i) (i)
#define void_from_char(i) (void)(i)
#define obj_from_char(i) mkimm(i, CHAR_ITAG)
/* strings */
static cxtype_t cxt_string = { "string", free };
cxtype_t *STRING_NTAG = &cxt_string;
extern cxtype_t *STRING_NTAG;
#define isstring(o) (isnative(o, STRING_NTAG))
#define stringdata(o) ((char*)getnative(o, STRING_NTAG))
#define mkstring(l, n, c) hpushptr(allocstring(n, c), STRING_NTAG, l)
#define cpstring(l, s) hpushptr(dupstring(s), STRING_NTAG, l)
extern char *dupstring(char *s);
char *dupstring(char *s) {
  assert(s); return strcpy(cxm_cknull(malloc(strlen(s)+1), "malloc(string)"), s);
}
extern char *allocstring(int n, int c);
char *allocstring(int n, int c) {
  char *s; assert(n+1 > 0); 
  s = cxm_cknull(malloc(n+1), "malloc(string)");
  memset(s, c, n); s[n] = 0;
  return s;
}
#ifndef NDEBUG
int stringlen(obj o) {
  char *s = stringdata(o);
  return (int)strlen(s); 
}
char* stringref(obj o, int i) {
  char *s = stringdata(o);
  int l = (int)strlen(s); 
  assert(i >= 0 && i < l);  
  return s+i;
}
#endif
#ifdef NDEBUG
  #define stringlen(o) ((int)strlen(stringdata(o)))
  #define stringref(o, i) (stringdata(o)+(i))
#else
  extern int stringlen(obj o);
  extern char* stringref(obj o, int i);
#endif
extern int strcmp_ci(char *s1, char*s2);
int strcmp_ci(char *s1, char *s2) {
    int c1, c2, d;
    do { c1 = *s1++; c2 = *s2++; d = (unsigned)tolower(c1) - (unsigned)tolower(c2); }
    while (!d && c1 && c2);
    return d;
}

/* cx globals */
obj cx_main; /* main */
obj cx_runtak; /* runtak */
obj cx_s0; /* s0 */
obj cx_s1; /* s1 */
obj cx_s10; /* s10 */
obj cx_s100; /* s100 */
obj cx_s12; /* s12 */
obj cx_s14; /* s14 */
obj cx_s16; /* s16 */
obj cx_s18; /* s18 */
obj cx_s2; /* s2 */
obj cx_s20; /* s20 */
obj cx_s4; /* s4 */
obj cx_s40; /* s40 */
obj cx_s6; /* s6 */
obj cx_s8; /* s8 */
obj cx_s80; /* s80 */
obj cx_string_2B; /* string+ */
obj cx_string_2D; /* string- */
obj cx_string_2Dappend; /* string-append */
obj cx_string_2Dfill_21; /* string-fill! */
obj cx_substring; /* substring */
obj cx_tak; /* tak */
static obj cx__2375; /* constant #75 */
static obj cx__2377; /* constant #77 */
static obj cx__2379; /* constant #79 */
static obj cx__2381; /* constant #81 */
static obj cx__2383; /* constant #83 */
static obj cx__2385; /* constant #85 */
static obj cx__2387; /* constant #87 */
static obj cx__2389; /* constant #89 */
static obj cx__2391; /* constant #91 */
static obj cx__2393; /* constant #93 */
static obj cx__2395; /* constant #95 */

/* helper functions */
/* string-fill! */
static obj cxs_string_2Dfill_21(obj v52_s, obj v51_c)
{ 
  { /* letrec */
    obj v56_i;
  { /* let */
    obj v173_tmp = obj_from_fixnum(0);
    /* tail call */
    v56_i = (v173_tmp);
    goto s_loop;
  }
  s_loop:
  if ((fixnum_from_obj(v56_i) == (stringlen((v52_s))))) {
    return ((0) ? obj_from_bool(0) : obj_from_void(0));
  } else {
    (void) obj_from_void(*stringref((v52_s), fixnum_from_obj(v56_i)) = char_from_obj(v51_c));
  { /* let */
    obj v172_tmp = obj_from_fixnum(fixnum_from_obj(v56_i) + (1));
    /* tail call */
    v56_i = (v172_tmp);
    goto s_loop;
  }
  }
  }
}

/* gc roots */
static obj *globv[] = {
  &cx_s0,
  &cx_s1,
  &cx_s10,
  &cx_s100,
  &cx_s12,
  &cx_s14,
  &cx_s16,
  &cx_s18,
  &cx_s2,
  &cx_s20,
  &cx_s4,
  &cx_s40,
  &cx_s6,
  &cx_s8,
  &cx_s80,
  &cx__2375,
  &cx__2377,
  &cx__2379,
  &cx__2381,
  &cx__2383,
  &cx__2385,
  &cx__2387,
  &cx__2389,
  &cx__2391,
  &cx__2393,
  &cx__2395,
};

static cxroot_t root = {
  sizeof(globv)/sizeof(obj *), globv, NULL
};

/* entry points */
static obj host(obj);
static obj cases[25] = {
  (obj)host,  (obj)host,  (obj)host,  (obj)host,  (obj)host,
  (obj)host,  (obj)host,  (obj)host,  (obj)host,  (obj)host,
  (obj)host,  (obj)host,  (obj)host,  (obj)host,  (obj)host,
  (obj)host,  (obj)host,  (obj)host,  (obj)host,  (obj)host,
  (obj)host,  (obj)host,  (obj)host,  (obj)host,  (obj)host,
};

/* host procedure */
#define MAX_HOSTREGS 28
static obj host(obj pc)
{
  register obj *r = cxg_regs;
  register obj *hp = cxg_hp;
  register int rc = cxg_rc;
  rreserve(MAX_HOSTREGS); 
jump: 
  switch (case_from_obj(pc)) {

case 0: /* load module */
    cx__2375 = (cpstring(0, "******************"));
    cx__2377 = (cpstring(0, "****************"));
    cx__2379 = (cpstring(0, "**************"));
    cx__2381 = (cpstring(0, "************"));
    cx__2383 = (cpstring(0, "**********"));
    cx__2385 = (cpstring(0, "********"));
    cx__2387 = (cpstring(0, "******"));
    cx__2389 = (cpstring(0, "****"));
    cx__2391 = (cpstring(0, "**"));
    cx__2393 = (cpstring(0, "*"));
    cx__2395 = (cpstring(0, ""));
    { static obj c[] = { obj_from_case(1) }; cx_substring = (obj)c; }
    { static obj c[] = { obj_from_case(2) }; cx_string_2Dappend = (obj)c; }
    { static obj c[] = { obj_from_case(5) }; cx_string_2Dfill_21 = (obj)c; }
    { static obj c[] = { obj_from_case(6) }; cx_string_2D = (obj)c; }
    { static obj c[] = { obj_from_case(7) }; cx_string_2B = (obj)c; }
    cx_s18 = (cx__2375);
    cx_s16 = (cx__2377);
    cx_s14 = (cx__2379);
    cx_s12 = (cx__2381);
    cx_s10 = (cx__2383);
    cx_s8 = (cx__2385);
    cx_s6 = (cx__2387);
    cx_s4 = (cx__2389);
    cx_s2 = (cx__2391);
    cx_s1 = (cx__2393);
    cx_s0 = (cx__2395);
    hreserve(hbsz(0+1), 0); /* 0 live regs */
    *--hp = obj_from_case(8);
    r[0] = (hendblk(0+1));
    r[1+0] = r[0];  
    r[1+1] = (cx_s10);
    r[1+2] = (cx_s10);
    r += 1; /* shift reg wnd */
    rreserve(MAX_HOSTREGS);
    goto gs_string_2B;

case 1: /* substring k s start end */
    assert(rc == 5);
    r += 1; /* shift reg. wnd */
gs_substring: /* k s start end */
    r[4] = (mkstring(4, (fixnum_from_obj(r[3]) - fixnum_from_obj(r[2])), '?'));
    r[5+0] = r[0];  
    r[5+1] = obj_from_fixnum(0);
    r[5+2] = r[1];  
    r[5+3] = r[4];  
    r[5+4] = r[3];  
    r[5+5] = r[2];  
    r += 5; /* shift reg wnd */
    rreserve(MAX_HOSTREGS);
    goto s_loop;

s_loop: /* k i s ss end start */
    { const fixnum_t v529_i = fixnum_from_obj(r[1]);
  if (((v529_i) >= (fixnum_from_obj(r[4]) - fixnum_from_obj(r[5])))) {
    /* r[0] */    
    pc = objptr_from_obj(r[0])[0];
    r[1] = obj_from_ktrap();
    r[2] = r[3];  
    rreserve(MAX_HOSTREGS);
    rc = 3;
    goto jump;
  } else {
    { const char_t v530_tmp = (*stringref((r[2]), (fixnum_from_obj(r[5]) + (v529_i))));
    (void)(*stringref((r[3]), (v529_i)) = (v530_tmp)); } 
    /* r[0] */    
    r[1] = obj_from_fixnum((v529_i) + (1));
    /* r[2] */    
    /* r[3] */    
    /* r[4] */    
    /* r[5] */    
    goto s_loop;
  } } 

case 2: /* string-append k a b */
    assert(rc == 4);
    r += 1; /* shift reg. wnd */
gs_string_2Dappend: /* k a b */
    r[3] = obj_from_fixnum(stringlen((r[1])));
    r[4] = (mkstring(4, (fixnum_from_obj(r[3]) + (stringlen((r[2])))), '?'));
    hreserve(hbsz(4+1), 5); /* 5 live regs */
    *--hp = r[4];  
    *--hp = r[0];  
    *--hp = r[2];  
    *--hp = r[3];  
    *--hp = obj_from_case(3);
    r[5] = (hendblk(4+1));
    r[6+0] = r[5];  
    r[6+1] = obj_from_fixnum(0);
    r[6+2] = r[4];  
    r[6+3] = r[1];  
    r[6+4] = r[3];  
    r += 6; /* shift reg wnd */
    rreserve(MAX_HOSTREGS);
    goto s_loop_v499;

s_loop_v499: /* k i s a al */
    { const fixnum_t v527_i = fixnum_from_obj(r[1]);
  if (((v527_i) >= fixnum_from_obj(r[4]))) {
    /* r[0] */    
    pc = objptr_from_obj(r[0])[0];
    r[1] = obj_from_ktrap();
    r[2] = ((0) ? obj_from_bool(0) : obj_from_void(0));
    rreserve(MAX_HOSTREGS);
    rc = 3;
    goto jump;
  } else {
    { const char_t v528_tmp = (*stringref((r[3]), (v527_i)));
    (void)(*stringref((r[2]), (v527_i)) = (v528_tmp)); } 
    /* r[0] */    
    r[1] = obj_from_fixnum((v527_i) + (1));
    /* r[2] */    
    /* r[3] */    
    /* r[4] */    
    goto s_loop_v499;
  } } 

case 3: /* clo ek . */
    assert(rc >= 2);
    r[2] = obj_from_void(0); /* ignored */
    { obj* p = objptr_from_obj(r[0]);
    r[1+2] = p[1];
    r[1+3] = p[2];
    r[1+4] = p[3];
    r[1+5] = p[4]; }
    r += 1; /* shift reg. wnd */
    /* ek . al b k s */
    hreserve(hbsz(2+1), 6); /* 6 live regs */
    *--hp = r[5];  
    *--hp = r[4];  
    *--hp = obj_from_case(4);
    r[6] = (hendblk(2+1));
    r[7+0] = r[6];  
    r[7+1] = obj_from_fixnum(0);
    r[7+2] = r[5];  
    r[7+3] = r[2];  
    r[7+4] = r[3];  
    r += 7; /* shift reg wnd */
    rreserve(MAX_HOSTREGS);
    goto s_loop_v490;

s_loop_v490: /* k i s al b */
    { const fixnum_t v525_i = fixnum_from_obj(r[1]);
  if (((v525_i) >= (stringlen((r[4]))))) {
    /* r[0] */    
    pc = objptr_from_obj(r[0])[0];
    r[1] = obj_from_ktrap();
    r[2] = ((0) ? obj_from_bool(0) : obj_from_void(0));
    rreserve(MAX_HOSTREGS);
    rc = 3;
    goto jump;
  } else {
    { const char_t v526_tmp = (*stringref((r[4]), (v525_i)));
    (void)(*stringref((r[2]), (fixnum_from_obj(r[3]) + (v525_i))) = (v526_tmp)); } 
    /* r[0] */    
    r[1] = obj_from_fixnum((v525_i) + (1));
    /* r[2] */    
    /* r[3] */    
    /* r[4] */    
    goto s_loop_v490;
  } } 

case 4: /* clo ek . */
    assert(rc >= 2);
    r[2] = obj_from_void(0); /* ignored */
    { obj* p = objptr_from_obj(r[0]);
    r[1+2] = p[1];
    r[1+3] = p[2]; }
    r += 1; /* shift reg. wnd */
    /* ek . k s */
    r[0] = r[2];  
    pc = objptr_from_obj(r[0])[0];
    r[1] = obj_from_ktrap();
    r[2] = r[3];  
    rreserve(MAX_HOSTREGS);
    rc = 3;
    goto jump;

case 5: /* string-fill! k s c */
    assert(rc == 4);
    r += 1; /* shift reg. wnd */
    /* k s c */
    r[3+0] = r[0];  
    pc = objptr_from_obj(r[3+0])[0];
    r[3+1] = obj_from_ktrap();
    r[3+2] = (cxs_string_2Dfill_21((r[1]), (r[2])));
    r += 3; /* shift reg wnd */
    rreserve(MAX_HOSTREGS);
    rc = 3;
    goto jump;

case 6: /* string- k s1 s2 */
    assert(rc == 4);
    r += 1; /* shift reg. wnd */
gs_string_2D: /* k s1 s2 */
    r[3+0] = r[0];  
    r[3+1] = r[1];  
    r[3+2] = obj_from_fixnum(0);
    r[3+3] = obj_from_fixnum((stringlen((r[1]))) - (stringlen((r[2]))));
    r += 3; /* shift reg wnd */
    rreserve(MAX_HOSTREGS);
    goto gs_substring;

case 7: /* string+ k s1 s2 */
    assert(rc == 4);
    r += 1; /* shift reg. wnd */
gs_string_2B: /* k s1 s2 */
    /* r[0] */    
    /* r[1] */    
    /* r[2] */    
    goto gs_string_2Dappend;

case 8: /* clo ek r */
    assert(rc == 3);
    r += 1; /* shift reg. wnd */
    /* ek r */
    cx_s20 = r[1];  
    hreserve(hbsz(0+1), 2); /* 2 live regs */
    *--hp = obj_from_case(9);
    r[2] = (hendblk(0+1));
    r[3+0] = r[2];  
    r[3+1] = (cx_s20);
    r[3+2] = (cx_s20);
    r += 3; /* shift reg wnd */
    rreserve(MAX_HOSTREGS);
    goto gs_string_2B;

case 9: /* clo ek r */
    assert(rc == 3);
    r += 1; /* shift reg. wnd */
    /* ek r */
    cx_s40 = r[1];  
    hreserve(hbsz(0+1), 2); /* 2 live regs */
    *--hp = obj_from_case(10);
    r[2] = (hendblk(0+1));
    r[3+0] = r[2];  
    r[3+1] = (cx_s40);
    r[3+2] = (cx_s40);
    r += 3; /* shift reg wnd */
    rreserve(MAX_HOSTREGS);
    goto gs_string_2B;

case 10: /* clo ek r */
    assert(rc == 3);
    r += 1; /* shift reg. wnd */
    /* ek r */
    cx_s80 = r[1];  
    hreserve(hbsz(0+1), 2); /* 2 live regs */
    *--hp = obj_from_case(11);
    r[2] = (hendblk(0+1));
    r[3+0] = r[2];  
    r[3+1] = (cx_s80);
    r[3+2] = (cx_s20);
    r += 3; /* shift reg wnd */
    rreserve(MAX_HOSTREGS);
    goto gs_string_2B;

case 11: /* clo ek r */
    assert(rc == 3);
    r += 1; /* shift reg. wnd */
    /* ek r */
    cx_s100 = r[1];  
    { static obj c[] = { obj_from_case(12) }; cx_tak = (obj)c; }
    { static obj c[] = { obj_from_case(19) }; cx_runtak = (obj)c; }
    { static obj c[] = { obj_from_case(23) }; cx_main = (obj)c; }
    r[2] = obj_from_void(0);
    r[3+0] = r[0];
    pc = 0; /* exit from module init */
    r[3+1] = r[2];  
    r += 3; /* shift reg wnd */
    rc = 2;
    goto jump;

case 12: /* tak k x y z */
    assert(rc == 5);
    r += 1; /* shift reg. wnd */
gs_tak: /* k x y z */
  if ((strcmp(stringdata((r[2])), stringdata((r[1]))) < 0)) {
    hreserve(hbsz(4+1), 4); /* 4 live regs */
    *--hp = r[0];  
    *--hp = r[1];  
    *--hp = r[2];  
    *--hp = r[3];  
    *--hp = obj_from_case(13);
    r[4] = (hendblk(4+1));
    r[0] = r[4];  
    /* r[1] */    
    r[2] = (cx_s1);
    goto gs_string_2D;
  } else {
    /* r[0] */    
    pc = objptr_from_obj(r[0])[0];
    r[1] = obj_from_ktrap();
    r[2] = r[3];  
    rreserve(MAX_HOSTREGS);
    rc = 3;
    goto jump;
  }

case 13: /* clo ek r */
    assert(rc == 3);
    { obj* p = objptr_from_obj(r[0]);
    r[1+2] = p[1];
    r[1+3] = p[2];
    r[1+4] = p[3];
    r[1+5] = p[4]; }
    r += 1; /* shift reg. wnd */
    /* ek r z y x k */
    hreserve(hbsz(4+1), 6); /* 6 live regs */
    *--hp = r[5];  
    *--hp = r[4];  
    *--hp = r[3];  
    *--hp = r[2];  
    *--hp = obj_from_case(14);
    r[6] = (hendblk(4+1));
    r[7+0] = r[6];  
    r[7+1] = r[1];  
    r[7+2] = r[3];  
    r[7+3] = r[2];  
    r += 7; /* shift reg wnd */
    rreserve(MAX_HOSTREGS);
    goto gs_tak;

case 14: /* clo ek r */
    assert(rc == 3);
    { obj* p = objptr_from_obj(r[0]);
    r[1+2] = p[1];
    r[1+3] = p[2];
    r[1+4] = p[3];
    r[1+5] = p[4]; }
    r += 1; /* shift reg. wnd */
    /* ek r z y x k */
    hreserve(hbsz(5+1), 6); /* 6 live regs */
    *--hp = r[5];  
    *--hp = r[1];  
    *--hp = r[4];  
    *--hp = r[3];  
    *--hp = r[2];  
    *--hp = obj_from_case(15);
    r[6] = (hendblk(5+1));
    r[0] = r[6];  
    r[1] = r[3];  
    r[2] = (cx_s1);
    goto gs_string_2D;

case 15: /* clo ek r */
    assert(rc == 3);
    { obj* p = objptr_from_obj(r[0]);
    r[1+2] = p[1];
    r[1+3] = p[2];
    r[1+4] = p[3];
    r[1+5] = p[4];
    r[1+6] = p[5]; }
    r += 1; /* shift reg. wnd */
    /* ek r z y x r k */
    hreserve(hbsz(5+1), 7); /* 7 live regs */
    *--hp = r[6];  
    *--hp = r[5];  
    *--hp = r[4];  
    *--hp = r[3];  
    *--hp = r[2];  
    *--hp = obj_from_case(16);
    r[7] = (hendblk(5+1));
    r[0] = r[7];  
    /* r[1] */    
    /* r[2] */    
    r[3] = r[4];  
    goto gs_tak;

case 16: /* clo ek r */
    assert(rc == 3);
    { obj* p = objptr_from_obj(r[0]);
    r[1+2] = p[1];
    r[1+3] = p[2];
    r[1+4] = p[3];
    r[1+5] = p[4];
    r[1+6] = p[5]; }
    r += 1; /* shift reg. wnd */
    /* ek r z y x r k */
    hreserve(hbsz(5+1), 7); /* 7 live regs */
    *--hp = r[6];  
    *--hp = r[5];  
    *--hp = r[1];  
    *--hp = r[4];  
    *--hp = r[3];  
    *--hp = obj_from_case(17);
    r[7] = (hendblk(5+1));
    r[0] = r[7];  
    r[1] = r[2];  
    r[2] = (cx_s1);
    goto gs_string_2D;

case 17: /* clo ek r */
    assert(rc == 3);
    { obj* p = objptr_from_obj(r[0]);
    r[1+2] = p[1];
    r[1+3] = p[2];
    r[1+4] = p[3];
    r[1+5] = p[4];
    r[1+6] = p[5]; }
    r += 1; /* shift reg. wnd */
    /* ek r y x r r k */
    hreserve(hbsz(3+1), 7); /* 7 live regs */
    *--hp = r[6];  
    *--hp = r[5];  
    *--hp = r[4];  
    *--hp = obj_from_case(18);
    r[7] = (hendblk(3+1));
    r[8+0] = r[7];  
    r[8+1] = r[1];  
    r[8+2] = r[3];  
    r[8+3] = r[2];  
    r += 8; /* shift reg wnd */
    rreserve(MAX_HOSTREGS);
    goto gs_tak;

case 18: /* clo ek r */
    assert(rc == 3);
    { obj* p = objptr_from_obj(r[0]);
    r[1+2] = p[1];
    r[1+3] = p[2];
    r[1+4] = p[3]; }
    r += 1; /* shift reg. wnd */
    /* ek r r r k */
    r[5+0] = r[4];  
    r[5+1] = r[3];  
    r[5+2] = r[2];  
    r[5+3] = r[1];  
    r += 5; /* shift reg wnd */
    rreserve(MAX_HOSTREGS);
    goto gs_tak;

case 19: /* runtak k n r */
    assert(rc == 4);
    r += 1; /* shift reg. wnd */
gs_runtak: /* k n r */
  if ((strcmp(stringdata((r[1])), stringdata((cx_s0))) == 0)) {
    /* r[0] */    
    pc = objptr_from_obj(r[0])[0];
    r[1] = obj_from_ktrap();
    /* r[2] */    
    rreserve(MAX_HOSTREGS);
    rc = 3;
    goto jump;
  } else {
    hreserve(hbsz(2+1), 3); /* 3 live regs */
    *--hp = r[0];  
    *--hp = r[2];  
    *--hp = obj_from_case(20);
    r[3] = (hendblk(2+1));
    r[0] = r[3];  
    /* r[1] */    
    r[2] = (cx_s1);
    goto gs_string_2D;
  }

case 20: /* clo ek r */
    assert(rc == 3);
    { obj* p = objptr_from_obj(r[0]);
    r[1+2] = p[1];
    r[1+3] = p[2]; }
    r += 1; /* shift reg. wnd */
    /* ek r r k */
    hreserve(hbsz(3+1), 4); /* 4 live regs */
    *--hp = r[3];  
    *--hp = r[1];  
    *--hp = r[2];  
    *--hp = obj_from_case(21);
    r[4] = (hendblk(3+1));
    r[0] = r[4];  
    r[1] = (cx_s18);
    r[2] = (cx_s12);
    r[3] = (cx_s6);
    goto gs_tak;

case 21: /* clo ek r */
    assert(rc == 3);
    { obj* p = objptr_from_obj(r[0]);
    r[1+2] = p[1];
    r[1+3] = p[2];
    r[1+4] = p[3]; }
    r += 1; /* shift reg. wnd */
    /* ek r r r k */
    hreserve(hbsz(2+1), 5); /* 5 live regs */
    *--hp = r[4];  
    *--hp = r[3];  
    *--hp = obj_from_case(22);
    r[5] = (hendblk(2+1));
    r[6+0] = r[5];  
    r[6+1] = r[2];  
    r[6+2] = r[1];  
    r += 6; /* shift reg wnd */
    rreserve(MAX_HOSTREGS);
    goto gs_string_2B;

case 22: /* clo ek r */
    assert(rc == 3);
    { obj* p = objptr_from_obj(r[0]);
    r[1+2] = p[1];
    r[1+3] = p[2]; }
    r += 1; /* shift reg. wnd */
    /* ek r r k */
    r[4+0] = r[3];  
    r[4+1] = r[2];  
    r[4+2] = r[1];  
    r += 4; /* shift reg wnd */
    rreserve(MAX_HOSTREGS);
    goto gs_runtak;

case 23: /* main k argv */
    assert(rc == 3);
    r += 1; /* shift reg. wnd */
    /* k argv */
    hreserve(hbsz(1+1), 2); /* 2 live regs */
    *--hp = r[0];  
    *--hp = obj_from_case(24);
    r[2] = (hendblk(1+1));
    r[3+0] = r[2];  
    r[3+1] = (cx_s100);
    r[3+2] = (cx_s0);
    r += 3; /* shift reg wnd */
    rreserve(MAX_HOSTREGS);
    goto gs_runtak;

case 24: /* clo ek r */
    assert(rc == 3);
    { obj* p = objptr_from_obj(r[0]);
    r[1+2] = p[1]; }
    r += 1; /* shift reg. wnd */
    /* ek r k */
    (void)(fputs(stringdata((r[1])), stdout));
    r[0] = r[2];  
    pc = objptr_from_obj(r[0])[0];
    r[1] = obj_from_ktrap();
    r[2] = obj_from_void(putchar('\n'));
    rreserve(MAX_HOSTREGS);
    rc = 3;
    goto jump;

default: /* inter-host call */
    cxg_hp = hp;
    cxm_rgc(r, MAX_HOSTREGS);
    cxg_rc = rc;
    return pc;
  }
}

/* module load */
void MODULE(void)
{
  obj pc;
  if (!root.next) {
    root.next = cxg_rootp;
    cxg_rootp = &root;
    LOAD();
    pc = obj_from_case(0);
    cxg_rc = 0;
    while (pc) pc = (*(cxhost_t*)pc)(pc); 
    assert(cxg_rc == 2);
  }
}

/* basic runtime */
#define HEAP_SIZE 131072 /* 2^17 */
#define REGS_SIZE 4092

obj *cxg_heap = NULL;
cxoint_t cxg_hmask = 0;
obj *cxg_hp = NULL;
static cxroot_t cxg_root = { 0, NULL, NULL };
cxroot_t *cxg_rootp = &cxg_root;
obj *cxg_regs = NULL, *cxg_rend = NULL;
int cxg_rc = 0;
char **cxg_argv = NULL;

static obj *cxg_heap2 = NULL;
static size_t cxg_hsize = 0; 
static cxoint_t cxg_hmask2 = 0;
static int cxg_gccount = 0, cxg_bumpcount = 0;

static obj *toheap2(obj* p, obj *hp, obj *h1, cxoint_t m1, obj *h2, cxoint_t m2)
{
  obj o = *p, *op, fo, *fop;
  if (((char*)(o) - (char*)h1) & m1) return hp;
  fo = (op = objptr_from_obj(o))[-1]; assert(fo);
  if (notaptr(fo)) {
    fop = op + size_from_obj(fo); while (fop >= op) *--hp = *--fop;
    *p = *fop = obj_from_objptr(hp+1);
  } else if (((char*)(fo) - (char*)h2) & m2) {
    *--hp = *op--; *--hp = *op;
    *p = *op = obj_from_objptr(hp+1);
  } else *p = fo;
  return hp;
}

static void finalize(obj *hp1, obj *he1, obj *h2, cxoint_t m2)
{
  while (hp1 < he1) {
    obj fo = *hp1++; assert(fo);
    if (notaptr(fo)) hp1 += size_from_obj(fo);
    else if (((char*)(fo) - (char*)h2) & m2) ((cxtype_t*)fo)->free((void*)*hp1++);
    else if (notaptr(fo = objptr_from_obj(fo)[-1])) hp1 += size_from_obj(fo);
    else ++hp1;
  } assert(hp1 == he1);
}

static obj *relocate(cxroot_t *pr, obj *regs, obj *regp, 
obj *he2, obj *he1, obj *hp, obj *h1, cxoint_t m1, obj *h2, cxoint_t m2) 
{
  obj *p, *hp1 = hp; hp = he2;
  for (p = regs; p < regp; ++p) hp = toheap2(p, hp, h1, m1, h2, m2);
  for (; pr; pr = pr->next) {
    obj **pp = pr->globv; int c = pr->globc;
    while (c-- > 0) hp = toheap2(*pp++, hp, h1, m1, h2, m2);
  }
  for (p = he2; p > hp; --p) hp = toheap2(p-1, hp, h1, m1, h2, m2);
  if (he1) finalize(hp1, he1, h2, m2);
  return hp;
}

obj *cxm_hgc(obj *regs, obj *regp, obj *hp, size_t needs) 
{
  obj *h1 = cxg_heap, *h2 = cxg_heap2; cxoint_t m1 = cxg_hmask, m2 = cxg_hmask2;
  size_t hs = cxg_hsize; cxroot_t *pr = cxg_rootp;

  obj *h = h1, *he1 = h1 + hs, *he2 = h2 + hs; 
  ++cxg_gccount;
  if (h1) hp = relocate(pr, regs, regp, he2, he1, hp, h1, m1, h2, m2), 
    needs += (h2 + hs - hp)*2; /* make heap half empty */
  else hp = h2 + hs;
  if (hs < needs) {
    size_t s = HEAP_SIZE; while (s < needs) s *= 2;
    m2 = 1 | ~(s*sizeof(obj)-1);
    if (!(h = realloc(h1, s*sizeof(obj)))) { perror("alloc[h]"); exit(2); }
    h1 = h2; h2 = h; he2 = h2 + s; he1 = 0; /* no finalize flag */
    if (h1) hp = relocate(pr, regs, regp, he2, he1, hp, h1, m1, h2, m2);
    else hp = h2 + s;
    if (!(h = realloc(h1, s*sizeof(obj)))) { perror("alloc[h]"); exit(2); }
    hs = s; m1 = m2; ++cxg_bumpcount;
  }
  h1 = h2; h2 = h;

  cxg_heap = h1; cxg_hmask = m1; cxg_heap2 = h2; cxg_hmask2 = m2;
  cxg_hsize = hs; return cxg_hp = hp;
}

obj *cxm_rgc(obj *regs, size_t needs) 
{
  obj *p = cxg_regs; assert(needs > 0);
  if (!p || cxg_rend < p + needs) {
    size_t roff = regs ? regs - p : 0;
    if (!(p = realloc(p, needs*sizeof(obj)))) { perror("alloc[r]"); exit(2); }
    cxg_regs = p; cxg_rend = p + needs;
    regs = p + roff;
  }
  if (regs && regs > p) while (needs--) *p++ = *regs++;
  return cxg_regs;
}

void cxm_check(int x, char *msg)
{
  if (!x) { 
    perror(msg); exit(2); 
  }
}

void *cxm_cknull(void *p, char *msg)
{
  cxm_check(p != NULL, msg); 
  return p;
}

/* os entry point */
int main(int argc, char **argv) {
  int res; obj pc;
  obj retcl[1] = { 0 };
  cxm_rgc(NULL, REGS_SIZE);
  cxg_argv = argv;
  MODULE();
  cxg_regs[0] = cx_main;
  cxg_regs[1] = (obj)retcl;
  cxg_regs[2] = (obj)argv;
  cxg_rc = 3;
  pc = objptr_from_obj(cx_main)[0];
  while (pc) pc = (*(cxhost_t*)pc)(pc); 
  assert(cxg_rc == 3);
  res = (cxg_regs[2] != 0); 
  /* fprintf(stderr, "%d collections, %d reallocs\n", cxg_gccount, cxg_bumpcount); */
  return res; 
}
